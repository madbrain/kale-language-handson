<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kale Language Hands&#x27;on</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Le langage Kale et son interpréteur</li><li class="chapter-item expanded "><a href="01_Interpreteur/01_Preparation.html"><strong aria-hidden="true">1.</strong> Préparation</a></li><li class="chapter-item expanded "><a href="01_Interpreteur/02_Lexer.html"><strong aria-hidden="true">2.</strong> Analyseur Lexical</a></li><li class="chapter-item expanded "><a href="01_Interpreteur/03_Parser.html"><strong aria-hidden="true">3.</strong> Analyseur Grammatical</a></li><li class="chapter-item expanded "><a href="01_Interpreteur/04_Interpreteur.html"><strong aria-hidden="true">4.</strong> Interpréteur</a></li><li class="chapter-item expanded affix "><li class="part-title">Un langage robuste</li><li class="chapter-item expanded "><a href="02_Robustesse/01_Reporting.html"><strong aria-hidden="true">5.</strong> Préparation</a></li><li class="chapter-item expanded "><a href="02_Robustesse/02_Lexer.html"><strong aria-hidden="true">6.</strong> Lexer</a></li><li class="chapter-item expanded "><a href="02_Robustesse/03_Parser.html"><strong aria-hidden="true">7.</strong> Parser</a></li><li class="chapter-item expanded "><a href="02_Robustesse/04_Semantique.html"><strong aria-hidden="true">8.</strong> Sémantique</a></li><li class="chapter-item expanded affix "><li class="part-title">Serveur de langage</li><li class="chapter-item expanded "><a href="03_ExtensionVSCode/01_Decouverte.html"><strong aria-hidden="true">9.</strong> Découverte</a></li><li class="chapter-item expanded "><a href="03_ExtensionVSCode/02_ServeurLangage.html"><strong aria-hidden="true">10.</strong> Serveur de langage Kale</a></li><li class="chapter-item expanded "><a href="03_ExtensionVSCode/03_ExtensionVSCode.html"><strong aria-hidden="true">11.</strong> Extension VSCode</a></li><li class="chapter-item expanded "><a href="03_ExtensionVSCode/04_ExtensionVim.html"><strong aria-hidden="true">12.</strong> Extension Vim</a></li><li class="chapter-item expanded affix "><li class="part-title">Vers de l'outillage de pro</li><li class="chapter-item expanded "><a href="04_Amelioration/01_Preparation.html"><strong aria-hidden="true">13.</strong> Langage amélioré</a></li><li class="chapter-item expanded "><a href="05_AdvanceFeatures/01_Preparation.html"><strong aria-hidden="true">14.</strong> Fonctionnalités avancées</a></li><li class="chapter-item expanded affix "><a href="06_Conclusion/01_Conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kale Language Hands&#x27;on</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Les DSL (<em>Domain Specific Language</em>) sont partout, nous les utilisons tous les jours sans vraiment s'en rendre compte
(SQL, Maven, Ansible, etc. <a href="https://tomassetti.me/domain-specific-languages/">encore plus d'exemples</a>).
Les méthodologies de conception telles que le DDD (<em>Domain Driven Design</em>)
invitent a représenter le domaine métier au travers d'un langage clairement défini : un DSL.
Les DSL ont donc pour but de nous rendre plus productif en se concentrant sur l'essentiel.
Mais l'accroissement du nombre de langage à apprendre et à maîtriser peut rendre la tâche ardue.</p>
<p>Le DSL doit être accompagné de l'outillage permettant un apprentissage rapide.
Dans l'ère post-IntelliJ<sup class="footnote-reference"><a href="#1">1</a></sup>, cet outillage doit au minimum :</p>
<ul>
<li>afficher des erreurs à la frappe,</li>
<li>fournir une complétion de code intelligente,</li>
<li>permettre des refactorings.</li>
</ul>
<h2 id="types-de-dsl"><a class="header" href="#types-de-dsl">Types de DSL</a></h2>
<p>Pour une analyse plus en profondeur de l'utilisation des langages spécifiques et de l'outillage associé,
je vous invite à lire l'<a href="https://www.martinfowler.com/articles/languageWorkbench.html">article de Martin Fowler</a>.</p>
<p>Voici pour résumer les différentes implémentations possibles d'un DSL.</p>
<h3 id="dsl-interne"><a class="header" href="#dsl-interne">DSL Interne</a></h3>
<p>Un DSL interne utilise la syntaxe de votre langage hôte (Java, Groovy, Python, etc.),
l'outillage est donc le même. Par contre en fonction des capacités du langage hôte, l'expressivité peut être limitée
et il est souvent difficiles d'exprimer des constructions complexes
(vérification de contraintes liées aux données, etc.).</p>
<h3 id="dsl-externe-"><a class="header" href="#dsl-externe-">DSL externe :</a></h3>
<h4 id="langage-valise"><a class="header" href="#langage-valise">Langage valise</a></h4>
<p>La grande tendance a été d'utiliser des langages comme XML, JSON et maintenant YAML comme DSL, certainement
pour leur outillage standard (grand nombre de bibliothèque de lecture/écriture). Ces outils sont aussi
leur faiblesse, même s'ils possèdent parfois la notion de schéma, ils n'ont pas été conçus pour aider les utilisateurs
avec la sémantique spécifique des langages métiers.</p>
<p>Finalement ces syntaxes clés en main contiennent :</p>
<ul>
<li>plus de bruit que de contenu (XML)</li>
<li>des constructions alternatives ambiguës (YAML).</li>
</ul>
<h4 id="langage-propre"><a class="header" href="#langage-propre">Langage propre</a></h4>
<p>L'écriture d'analyseurs spécifiques à un langage (lexer/parser) est perçue par la plupart des développeurs
comme une tâche compliquée voire intimidante, certainement une réminiscence des cours de compilation qui
avait pour objectifs d'expliquer les techniques de compilation pour un language généraliste.
La portée d'un DSL (comme son nom l'indique) est bien plus restreinte et les techniques misent en œuvre
pour l'analyser suivent la même tendance.</p>
<p>Nombre d'outils sont disponibles pour aider à la réalisation de lexer/parser (flex, bison, ANTLR, etc.).
Ces outils permettent d'être rapidement productif, mais deviendront à un moment ou un autre également le facteur limitant :</p>
<ul>
<li>ils n'aident pas vraiment à comprendre la théorie (malheureusement indispensable) de l'analyse de langage (LL/LR, récursivité à gauche, etc.)</li>
<li>il est souvent difficile de comprendre le fonctionnement du code qu'ils produisent et offrent un débogage limité</li>
<li>et il est difficile, voire impossible, de personnaliser leur fonctionnement pour les faire correspondre à vos besoins précis.
En particulier la gestion robuste des erreurs qui se produisent systématiquement dans le cas d'une analyse interactive où
l'utilisateur écrit son code progressivement.</li>
</ul>
<p>Il est en fait souvent plus simple d'écrire son propre lexer/parser pour des petits langages comme les DSL.
Cela permet de réaliser l'ensemble des modifications nécessaires aux spécificités du traitement interactif
grace à un code 100% maîtrisé. Et nous allons voir qu'en quelques étapes il est possible d'obtenir un outillage
robuste et puissant pour un petit DSL.</p>
<h2 id="objectifs"><a class="header" href="#objectifs">Objectifs</a></h2>
<p>Les objectifs ambitieux mais réalisables sont :</p>
<ul>
<li>Écrire l'outillage pour aider à l'écriture d'un petit DSL, avec entre autre :
<ul>
<li>affichage des erreurs à la frappe</li>
<li>complétion de code</li>
<li>refactoring</li>
</ul>
</li>
<li>Intégration de l'outillage dans VSCode ou une application Web.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>«post-IntelliJ» est le terme utilisé par Martin Fowler, je n'ai personnellement aucun a priori, remplacez par votre IDE à tout faire préféré!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="préparation-du-projet"><a class="header" href="#préparation-du-projet">Préparation du projet</a></h1>
<p>Pour mener à bien vôtre mission quelques outils vous seront nécessaires:</p>
<ul>
<li><a href="https://git-scm.com/">Git</a></li>
<li><a href="https://nodejs.org/">Node.js</a></li>
<li><a href="https://code.visualstudio.com">Visual Studio Code</a></li>
</ul>
<p>Commencez par cloner la souche du projet:</p>
<pre><code>git clone https://github.com/madbrain/kale-language-server.git
</code></pre>
<p>Ce projet contient tout le nécessaire pour construire l'outillage d'analyse de notre language.
Le développement sera guidé par des tests découpés en différentes étapes progressives,
à chaque étape de nouveaux tests nous amènent à écrire une nouvelle fonctionnalité.</p>
<p>Le projet contient:</p>
<ul>
<li><code>src</code>, les sources de l'analyseur sur lesquelles nous allons nous concentrer durant le tutoriel ;</li>
<li><code>bin</code>, les programmes exécutables qui vont nous permettre d'exploiter le langage (un interpréteur en fait).</li>
<li><code>examples</code>, quelques exemples de notre DSL.</li>
</ul>
<p>Les sources sont écrite principalement en Typescript ce qui permet de les utiliser sans adaptation
à la fois dans une application Web et aussi comme une extension VSCode.
Cependant aucun framework exotique n'est utilisé et il est extrêmement simple d'appliquer les mêmes techniques
avec n'importe quel langage de votre choix.</p>
<p>Pour démarrer le tutoriel il faut commencer par créer une branch à partir du tag <code>step-1.1</code> :</p>
<pre><code>git checkout -b tutoriel step-1.1
</code></pre>
<p>Il faut ensuite installer l'ensemble des dépendances nécessaire au tutoriel, pour cela exécutez la commande suivante:</p>
<pre><code>npm install
</code></pre>
<p>À chaque étape il faut compléter le code afin que l'ensemble des tests soit vert :</p>
<pre><code>npm test
</code></pre>
<p>Quand c'est le cas, il faut passer à l'étape suivante en fusionnant le tag suivant :</p>
<pre><code>git merge step-1.2
</code></pre>
<p>Si vous bloquez, vous pouvez consulter la solution proposée à chaque étape sur le tag correspondant,
par exemple la solution de l'étape <code>step-1.1</code> se trouve au tag <code>solution-step-1.1</code>.</p>
<h1 id="présentation-du-langage-kale1"><a class="header" href="#présentation-du-langage-kale1">Présentation du langage Kale<sup class="footnote-reference"><a href="#1">1</a></sup></a></h1>
<p>Le département comptabilité de votre entreprise réalise des calculs extrêmement complexes
pour lesquels les formules Excel ont atteint leur limites (depuis le temps qu'on le dit...)
et vous a missionné pour concevoir un langage simple mais facile à utiliser qui leur permettra
de simplifier leur dur labeur.</p>
<p>Voici le langage que vous avez conçu, il permet d'exprimer des calculs à l'aide
d'expressions arithmétiques et de variables, la variable <code>message</code> sera affichée à l'écran :</p>
<pre><code class="language-c">// Calcul du prix total
prix_unitaire := 10
forfait := 100
total := prix_unitaire * 20 + forfait
message := "Le prix est " + total
</code></pre>
<p>Ce langage va être analysé en plusieurs étapes :</p>
<ul>
<li>découpage du texte en mots : analyse lexicale</li>
<li>structuration des mots en phrases : analyse grammaticale</li>
<li>vérification du sens des phrases : analyse sémantique</li>
</ul>
<p>Chaque étapes repose sur les résultats produits à l'étape précédente.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>l'origine de ce nom reste un mystère : un chanteur de blues, un légume hype, le Kangooroo Arithmetic Language Evaluator ? qui sait...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analyseur-lexical"><a class="header" href="#analyseur-lexical">Analyseur lexical</a></h1>
<h2 id="principe"><a class="header" href="#principe">Principe</a></h2>
<p>L'analyseur lexical a pour but de produire à partir d'un texte
un flux de mots ou plus précisément de lexèmes (<em>token</em>).</p>
<p>À la différence des langues naturels qui évoluent et se complexifient de façon organique au grès des usages,
les langages informatiques sont conçus avec l'idée qu'ils doivent être analysables par un algorithme.
Et cet algorithme doit autant que possible être le plus simple possible. Pour modéliser l'analyse lexicale
les <a href="https://fr.wikipedia.org/wiki/Expression_r%C3%A9guli%C3%A8re">expressions régulières</a> sont classiquement utilisées.</p>
<p>Principe de l'analyse lexicale :</p>
<ul>
<li>le texte est lu caractère par caractère en partant du début</li>
<li>à chaque caractère lu l'analyseur change d'état</li>
<li>à chaque transition dans un nouvel état, l'analyseur nous indique :
<ul>
<li>si le texte lu est identifié comme un lexème connu</li>
<li>si le texte lu ne peut en aucun cas correspondre à un lexème connu et qu'il est donc en erreur</li>
<li>sinon l'analyse continue</li>
</ul>
</li>
<li>à chaque lexème trouvé, l'analyseur reprend dans l'état initial</li>
<li>par défaut l'analyseur essaie de trouver les lexèmes les plus long possible.</li>
</ul>
<p>Ce principe est illustré par l'animation suivante :</p>
<p><img src="01_Interpreteur/lexer-animation.gif" alt="Automate d&#39;analyse" /></p>
<h2 id="implémentation"><a class="header" href="#implémentation">Implémentation</a></h2>
<p>Les lexèmes sont représentés par les définitions suivantes :</p>
<pre><code class="language-typescript">interface Token {
    type: TokenKind;
    value?: string;
}

enum TokenKind {
    IDENT = "IDENT",
    INTEGER = "INTEGER",
    STRING = "STRING",
    // ...
}
</code></pre>
<p>Le lexer se construit à partir d'une chaîne de caractères contenant le texte à analyser,
la variable <code>position</code> indique la position du prochain caractère à consommer.
Chaque appel à la méthode <code>nextToken</code> renvoie le lexème suivant trouvé à partir de <code>position</code>.
Les trois méthodes <code>atEnd</code>, <code>getChar</code> et <code>putBackChar</code> permettent de manipuler le flux de caractères.</p>
<pre><code class="language-typescript">class Lexer {
    private position = 0;
    
    constructor (private content: String) {}

    nextToken(): Token {
        raise Error("TODO: not complete");
    }

    private atEnd() {
        return this.position &gt;= this.content.length;
    }

    private getChar() {
        return this.content[this.position++];
    }

    private putBackChar() {
        this.position--;
    }
}
</code></pre>
<p>L'automate des états de l'analyseur est implémenté dans la méthode <code>nextToken</code> :</p>
<ul>
<li>les transitions sont implémentées avec une échelle de <code>if</code>/<code>else if</code></li>
<li>dans chaque <code>if</code> correspondant à une transition, on y trouve le code de l'état correspondant :
<ul>
<li>soit l'état correspond à un lexème possible alors ce lexème est retourné</li>
<li>soit des transitions sont possibles et l'analyse continue</li>
<li>sinon une erreur est déclenchée</li>
</ul>
</li>
<li>les boucles sont implémentées par des boucles de type <code>while</code> (logique non?)</li>
</ul>
<p>L'implémentation de la méthode <code>nextToken</code> peut suivre la structure suivante :</p>
<pre><code class="language-typescript">nextToken(): Token {
    if (this.atEnd()) {
        return { kind: TokenKind.EOF };
    }
    const c = this.getChar();
    if (isDigit(c)) {
        return this.integer(c);
    } else if (c == ':') {
        if (this.getChar() == '=') {
            return { kind: TokenKind.ASSIGN };
        }
        this.pustBackChar();
    } else {
        throw Error("TODO: not complete");
    }
    throw Error(`Unexpected char '${c}'`);
}
</code></pre>
<p>Le test d'une classe de caractères peut être factorisé dans des fonctions utilitaires, comme par exemple :</p>
<pre><code class="language-typescript">function isDigit(c: string) {
    return c &gt;= '0' &amp;&amp; c &lt;= '9';
}

function isSpace(c: string) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}
</code></pre>
<p>Les caractères correspondant à la classe <code>LAYOUT</code> sont ignorés et ne génèrent pas de token.</p>
<h2 id="résultats"><a class="header" href="#résultats">Résultats</a></h2>
<p>Une fois que l'ensemble des tests de l'étape <code>step-1.1</code> passent au vert (<code>npm test</code>), il est possible de tester concrètement
le résultat de cette étape en compilant le projet avec <code>npm run build</code>, puis en lançant la commande suivante sur l'un des exemples disponibles :</p>
<pre><code>./bin/kale-interpreter examples/simple_example.kl
</code></pre>
<p>Le programme doit afficher la liste des tokens du fichier passé en paramètre.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analyseur-grammatical"><a class="header" href="#analyseur-grammatical">Analyseur grammatical</a></h1>
<h2 id="principe-1"><a class="header" href="#principe-1">Principe</a></h2>
<p>Maintenant que vous disposez d'un analyseur lexical capable de découper le code source en lexèmes,
il est tant d'en extraire la structure. Comme pour les langages naturels, le concept de grammaire est
utilisé pour décrire la structure du langage.</p>
<p>Voici la définition de la grammaire du langage Kale :</p>
<pre><code>KaleFile ::= Assignment* EOF
Assignment ::= IDENT ASSIGN Value
Value ::= MulDivValue ( epsilon | (+ | -) MulDivValue )*
MulDivValue ::= AtomValue ( epsilon | (* | /) AtomValue )*
AtomValue ::= INTEGER | IDENT | STRING
</code></pre>
<p>Les éléments de la grammaire entièrement en majuscule (ie. <code>INTEGER</code>) correspondent aux lexèmes et sont appelés les terminaux.
Les autres éléments sont les non-terminaux et représentent le résultat des règles qui structurent le langage.
La grammaire se lit de cette façon :</p>
<ul>
<li>la règle <code>Assignment ::= IDENT ASSIGN Value</code> signifie que la séquence formée de <code>IDENT</code>, <code>ASSIGN</code> et <code>Value</code> peut se réduire à <code>Assignment</code> ;</li>
<li><code>|</code> indique une alternative, ie. <code>INTEGER</code> ou <code>IDENT</code> ou <code>STRING</code> peuvent se réduire à <code>AtomValue</code>. Ceci est équivalent à avoir écrit séparément
les règles suivantes :</li>
</ul>
<pre><code>AtomValue ::= INTEGER
AtomValue ::= IDENT
AtomValue ::= STRING
</code></pre>
<ul>
<li><code>*</code> indique que l'élément précédent peut être répété 0 ou plusieurs fois ;</li>
<li>les parenthèses servent à préciser les priorités des opérations ;</li>
<li><code>epsilon</code> représente la séquence vide c.-à-d. l'absence d'éléments.</li>
</ul>
<p>La structure résultant de l'analyse du language est définie dans le fichier <code>ast.ts</code> : chaque interface correspond
à une règle de la grammaire .</p>
<p>Il faut maintenant définir la machine capable d'extraire la structure à partir de cette grammaire : le <em>parser</em>.
Les parsers sont classés en fonction de la complexité du langage qu'ils sont capable de reconnaître.
Les parsers les plus simples à implémenter sont ceux dit LL(1).</p>
<p>Attention ce type de parser ne permet pas d'être utilisé avec n'importe qu'elle grammaire :
elle ne doit pas contenir de <a href="https://en.wikipedia.org/wiki/LL_parser#Solutions_to_LL(1)_Conflicts">règles récursives à gauche et être factorisé</a>.
Mais pas d'inquiétude, cette grammaire a été écrite pour être de type LL(1)
(d'où les règles <code>Value</code> et <code>MulDivValue</code> écrites d'une façon pas très naturelle).</p>
<h2 id="implémentation-1"><a class="header" href="#implémentation-1">Implémentation</a></h2>
<p>Voici la structure générale du parser :</p>
<pre><code class="language-typescript">class Parser {
    private token: Token;
    
    constructor(private lexer: Lexer) {
        this.token = this.scanToken()
    }

    parseFile(): KaleFile {
        throw new Error("TODO: not complete");
    }

    private scanToken() {
        this.token = this.lexer.nextToken();
        return this.token;
    }

    private test(kind: TokenKind) {
        if (this.token.kind == kind) {
            this.scanToken();
            return true;
        }
        return false;
    }

    private expect(kind: TokenKind) {
        if (this.token.kind != kind) {
            throw new Error(`Expecting token ${kind}, got ${this.token.kind}`);
        }
        this.scanToken();
    }
}
</code></pre>
<p>Les parsers de type LL(1) peuvent être écrit sous la forme d'un automate procédurale, c.-à-d. que chaque
non-terminal de la grammaire est décrit par une méthode du parser. Par exemple la règle <code>Assignment ::= IDENT ASSING Value</code>
va se traduire en :</p>
<pre><code class="language-typescript">class Parser {
    private parseAssignment(): Assignment {
        const variable = this.parseIdent();
        this.expect(TokenKind.ASSIGN);
        const value = this.parseValue();
        return { variable, value };
    }
}
</code></pre>
<p>Si lors de l'analyse d'un non-terminal peut se poursuivre par plusieurs types de lexèmes : ils seront tout à tour tester avec la fonction <code>test</code>.
Les répétitions dans la grammaire représentées par <code>*</code> deviennent des boucles dans le parser.</p>
<h2 id="résultat"><a class="header" href="#résultat">Résultat</a></h2>
<p>Une fois que l'ensemble des tests de l'étape <code>step-1.2</code> passent au vert (<code>npm test</code>), il est possible de tester
le résultat du parser sur les fichiers d'exemples (après compilation avec <code>npm run build</code>) :</p>
<pre><code>./bin/kale-interpreter examples/simple_example.kl
</code></pre>
<p>Le programme doit maintenant afficher l'arbre de syntaxe au format Json.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpréteur"><a class="header" href="#interpréteur">Interpréteur</a></h1>
<h2 id="principe-2"><a class="header" href="#principe-2">Principe</a></h2>
<p>Un fois l'arbre de syntaxe obtenu avec le parser, il est possible de l'interpréter afin d'obtenir le résultat
réel du calcul. Pour les puristes, l'interpréteur peut se définir à partir de la
<a href="https://en.wikipedia.org/wiki/Operational_semantics">sémantique opérationnelle</a> suivante:</p>
<p>$$
\frac{\langle E,s\rangle \Rightarrow V}{\langle L:=E,,,s\rangle\longrightarrow (s\uplus (L\mapsto V))}
$$</p>
<p>$$
\frac{\langle E_1,s\rangle \Rightarrow V_1,\langle E_2,s\rangle \Rightarrow V_2}{\langle E_1 op E_2,s\rangle\longrightarrow (V_1 op V_2)}
$$</p>
<p>$$
\frac{}{\langle I,s\rangle\longrightarrow (I)}
$$</p>
<p>$$
\frac{}{\langle S,s\rangle\longrightarrow (S)}
$$</p>
<p>$$
\frac{(L\mapsto V) \in s}{\langle L,s\rangle\longrightarrow (V)}
$$</p>
<p>$$
\frac{\langle A_1,s\rangle \longrightarrow s'}{\langle A_1 A_2,s\rangle \longrightarrow \langle A_2,s'\rangle}
$$</p>
<p>$$
\frac{(message\mapsto V) \in s}{\langle ,s\rangle \longrightarrow print(V)}
$$</p>
<p>Si ce charabia mathématique n'a aucun sens pour vous : c'est pas grave !
Les définitions ci-dessus comportent de plus certainement quelques erreurs, mais il est important d'avoir une idée des outils
standards utilisés dans la conception de langages. En effet un bon langage doit reposer sur des bases solides
et la définition formelle de sa sémantique en est une.</p>
<p>Globalement les règles ci-dessus indiquent que tout au long de l'évaluation du programme un état \(s\) va être lu et mis à jour.
De façon concrète cet état est du type <code>Map&lt;string, string | number&gt;</code> et permet de stocker le résultat de l'évaluation des affectations.
La sémantique indique également que :</p>
<ul>
<li>les affections sont évaluées dans l'ordre dans lequel elles apparaissent dans le fichier</li>
<li>la valeur de l'affectation est calculée par évaluation des opérations</li>
<li>la valeur d'une variable est lue depuis l'état</li>
<li>et à la fin la valeur de la variable <code>message</code> est affichée.</li>
</ul>
<h2 id="résultat-1"><a class="header" href="#résultat-1">Résultat</a></h2>
<p>Une fois que l'ensemble des tests de l'étape <code>step-1.3</code> passent au vert, il est possible de tester
le résultat de l'interpréteur sur les fichiers d'exemples :</p>
<pre><code>./bin/kale-interpreter example/simple_example.kl
</code></pre>
<p>Le programme affiche maintenant le résultat de l'évaluation tant attendu, hourra !.</p>
<h2 id="observations"><a class="header" href="#observations">Observations</a></h2>
<p>Mais pas si vite ! que se passe t-il si l'on essaye d'évaluer les programmes suivants :</p>
<pre><code>message := 30 @ "tutu"
</code></pre>
<pre><code>message := 30 + / "tutu"
</code></pre>
<pre><code>message := 30 * "tutu"
</code></pre>
<p>Dans les deux premiers cas il plante lamentablement avec une indication d'erreur pas très explicite : est-ce une erreur dans le programme évalué
ou un bug dans l'interpréteur ? Il est clair qu'il y a respectivement une erreur lexicale et grammaticale dans les programmes d'exemples.
Mais à part le message, l'interpréteur ne nous donne aucune information de position (ligne, colonne) : imaginer trouver l'erreur dans un programme
de taille plus conséquente.</p>
<p>Les experts Javascript peuvent trouver le résultat de la dernière évaluation correct, par contre pour vos clients ça n'a aucun sens de multiplier un
nombre et une chaîne de caractères et l'interpréteur devrait clairement l'indiquer, tout comme utiliser une variable non définie, etc..</p>
<p>Il serait également intéressant que l'évaluateur soit robuste et soit capable d'indiquer l'ensemble des erreurs d'un programme et pas juste la première<sup class="footnote-reference"><a href="#1">1</a></sup>. Par exemple dans le programme suivant :</p>
<pre><code>my_var := 30 + / 50
message := "resultat : " + my_other_var
</code></pre>
<p>Il doit être capable d'indiquer une erreur au niveau du symbole <code>/</code> et que dans la deuxième expression il est fait référence
à la variable <code>my_other_var</code> non définie.</p>
<p>Dans la seconde partie du tutoriel nous allons rendre l'interpréteur robuste à tout types d'erreur et lui donner un rapport d'erreur précis.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>notre objectif est l'aide à l'écriture de code et contrairement à l'évaluation un programme, cela peut passer par des phases où il contient beaucoup d'erreurs (ie. pendant les phases de réfactoring).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meilleur-reporting"><a class="header" href="#meilleur-reporting">Meilleur reporting</a></h1>
<p>Afin de faciliter l'apprentissage du langage, il est important de donner un diagnostiques précis des erreurs
et en particulier indiquer la position de l'erreur : la ligne voire mieux l'intervalle dans la ligne en erreur.</p>
<p>Les utilisateurs peuvent à tout moment éditer un texte en erreur. Si l'erreur est située avant
leur position d'édition l'analyse s'arrête et ils n'auront alors aucune information de potentielles erreurs
à la position d'édition. Il est donc important d'avoir une analyse suffisamment robuste pour pouvoir indiquer
le maximum d'erreurs possibles à l'utilisateur et en particulier à la position d'édition.</p>
<h2 id="positionnement"><a class="header" href="#positionnement">Positionnement</a></h2>
<pre><code class="language-typescript">interface Position {
    offset: number;
    line: number;
    character: number;
}

interface Span {
    from: Position;
    to: Position
}
</code></pre>
<p>Les informations ligne/character et offset paraissent redondantes mais chaque éditeur de texte
gère le positionnement dans le texte de façon différente :</p>
<ul>
<li>le language Server Protocol utilisé par VSCode n'accepte que ligne/colonne ;</li>
<li>Codemirror accepte plutôt ligne/colonne, mais des fonctions de conversion existent ;</li>
<li>le positionnement brut dans un fichier est plus aisé avec l'offset.</li>
</ul>
<p>C'est donc une bonne pratique d'utiliser le triplet ligne/colonne/offset pour le positionnement dans le texte.</p>
<h2 id="rapport-derreurs-multiples"><a class="header" href="#rapport-derreurs-multiples">Rapport d'erreurs multiples</a></h2>
<p>Pour rapporter les erreurs, les différentes phases de l'analyse disposent d'un objet du type suivant :</p>
<pre><code class="language-typescript">interface ErrorReporter {
    reportError(span: Span, message: string);
}
</code></pre>
<h2 id="description-des-outils-de-test"><a class="header" href="#description-des-outils-de-test">Description des outils de test</a></h2>
<p>Afin de simplifier l'écriture des tests la fonction utilitaire <code>code</code> est utilisée pour définir à la fois le code à analyser
ainsi que la position de marqueurs (<code>@{1}</code>, <code>@{2}</code>, etc.). Ces marqueurs sont ensuite utilisés pour comparer avec les positions
fournies par le résultat de l'analyse.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robustesse-du-lexer"><a class="header" href="#robustesse-du-lexer">Robustesse du lexer</a></h1>
<h2 id="etape-1--ajout-du-positionnement-des-lexèmes"><a class="header" href="#etape-1--ajout-du-positionnement-des-lexèmes">Etape 1 : Ajout du positionnement des lexèmes</a></h2>
<p><code>step-2.1</code></p>
<p>Chaque lexème dispose maintenant d'un champ span qui reflète sa position exacte dans le fichier :</p>
<pre><code class="language-typescript">export Token {
  span: Span;
  kind: TokenKind;
  value?: string;
}
</code></pre>
<p>Les méthodes <code>getChar</code> et <code>putBackChar</code> doivent comptabiliser les positions (ligne et colonne)
à chaque fois qu'elles renvoient ou reprennent un caractère. Attention lorsque <code>putBackChar</code> reprend un retour chariot :
il faut retourner à la fin de la ligne précédente !</p>
<h2 id="etape-2--robustesse"><a class="header" href="#etape-2--robustesse">Etape 2 : Robustesse</a></h2>
<p><code>step-2.2</code></p>
<p>Afin d'être robuste, le lexer ne peut plus s'arrêter par une exception. Cela se produit sur deux types d'erreurs possibles :</p>
<ul>
<li>soit il a commencé à lire un lexème mais il ne se termine pas correctement
(ie. une chaîne de caractères sans délimiteur de fin) alors une erreur est rapportée mais le lexème est retourné avec la portion déjà lu.
S'il y a plusieurs types de lexème possibles, le type est choisi arbitrairement.</li>
<li>soit le caractère lu ne correspond à rien alors une erreur est rapportée et l'analyse reprend à l'état initial,
ce qui a pour effet d'ignorer le(s) caractère(s) en erreur.</li>
</ul>
<h2 id="résultat-2"><a class="header" href="#résultat-2">Résultat</a></h2>
<p>Le lexer ne s'arrête plus à la première erreur et rapporte précisément l'erreur. Par exemple sur le programme suivant :</p>
<pre><code>my_var := 10 @ + 30
message := "result :
</code></pre>
<p>L'interpréteur affiche maintenant le diagnostic d'erreur suivant :</p>
<pre><code>my_var := 10 @ + 30
             ^
[0] Unknown character(s)

message := "result :
           ^^^^^^^^^
[1] Unterminated string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robustesse-du-parser"><a class="header" href="#robustesse-du-parser">Robustesse du parser</a></h1>
<h2 id="etape-1--ajout-du-positionnement-de-larbre-de-syntaxe"><a class="header" href="#etape-1--ajout-du-positionnement-de-larbre-de-syntaxe">Etape 1 : Ajout du positionnement de l'arbre de syntaxe</a></h2>
<p><code>step-2.3</code></p>
<p>Chaque nœud de l'arbre de syntaxe dispose maintenant d'un champ span qui reflète sa position exacte dans le fichier :</p>
<pre><code class="language-typescript">export AstNode {
  span: Span;
}
</code></pre>
<p>La fonction <code>mergeSpan</code> est bien utile pour obtenir l'intervalle complet d'un nœud à partir de ses fils ou des lexèmes.</p>
<h2 id="etape-2--robustesse-1"><a class="header" href="#etape-2--robustesse-1">Etape 2 : Robustesse</a></h2>
<p><code>step-2.4</code></p>
<p>Actuellement lors d'une erreur de syntaxe le parser s'arrête avec une exception, il nous faut être capable de rapporter l'erreur
mais d'être capable de continuer l'analyse sur le reste du code.
Pour cela, la technique la plus simple est celle du <em>panic mode</em>.
Cette technique consiste, en cas d'erreur, à ignorer les lexèmes du flux
à la recherche d'un lexème de synchronisation. Les lexèmes de synchronisation sont choisis de telle sorte que
si l'analyse reprend à cet endroit elle a de grandes chances de se dérouler correctement.
L'analyse reprends avec la règle adéquate en fonction du lexème de synchronisation :
par exemple dans le langage C, le lexème qui suit <code>;</code> permet de redémarrer l'analyse au début d'une instruction.</p>
<p>Il est également possible d'insérer/modifier le(s) lexème(s) attendu(s) en espérant que l'analyse reprenne correctement,
par exemple en ajoutant une accolade de fin de bloc. Faire le bon choix entre les différentes modifications requiert généralement
de tester les différentes solutions et de choisir celle qui mène l'analyse la plus au delà de l'erreur précédente.
Ce mode de reprise sur erreur est plus performant en termes de capacité de récupération, mais est bien plus compliqué que le simple
<em>panic mode</em>.</p>
<p>Deux nouvelles méthodes utilitaires du parser sont nécessaires :</p>
<pre><code class="language-typescript">private recoverWith&lt;T&gt;(syncTokens: TokenKind[], start: Span,
                       makeError: (span: Span) =&gt; T, parseFunc: () =&gt; T): T {
    try {
        return parseFunc();
    } catch(e) {
        const tokens = this.skipTo(syncTokens);
        const range = tokens.length &gt; 0 ? mergeSpan(start, tokens[tokens.length-1].span) : start;
        return makeError(range);
    }
}

private skipTo(syncTokens: TokenKind[]): Token[] {
    const tokens: Token[] = []
    while (! (this.token.kind == TokenKind.EOF || syncTokens.indexOf(this.token.kind) &gt;= 0)) {
        tokens.push(this.token);
        this.scanToken();
    }
    return tokens;
}
</code></pre>
<p>La méthode <code>recoverWith</code> permet de protéger l'exécution du bloc de code d'analyse <code>parseFunc</code> et, en cas d'erreur
pendant l'analyse, <code>skipTo</code> avance la lecture des lexèmes jusqu'à rencontrer un token de synchronisation ou <code>EOF</code>.
La fonction <code>makeError</code> permet de construire un nœud de syntaxe représentant le fait qu'il y a eu une erreur
sur l'intervalle en paramètre.</p>
<p>Par exemple lors de l'analyse d'une condition <code>Condition ::= Expr EQUALS Expr</code>, si une erreur survient pendant l'analyse
de la deuxième expression, on construit un nœud partiel contenant le maximum d'information accumulée jusque là :</p>
<pre><code class="language-typescript">private parseCondition(): Condition {
  const startSpan = this.token.span;
  const left = parseExpr();
  expect(TokenKind.EQUALS);
  return this.recoverWith(CONDITION_SYNC_TOKENS, startSpan, (endSpan) =&gt; {
      return { span: mergeSpan(startSpan, endSpan), isOk: false, op: Relation.Equals, left };
  }, () =&gt; {
      const right = parseExpr();
      return { span: mergeSpan(expr.span, right.span), isOk: true, op: Relation.Equals, left, right };
  });
}
</code></pre>
<p>L'analyse reprendra sur un des lexèmes de <code>CONDITION_SYNC_TOKENS</code>. Cet ensemble de lexèmes doit permettre de redémarrer l'analyse comme
si le non-terminal <code>Condition</code> avait été émit et contient donc l'ensemble des lexèmes valides après ce non-terminal.</p>
<p>Chaque non-terminal a un ensemble de lexèmes de synchronisation différent et correspond aux fameux <a href="https://www.cs.uaf.edu/~cs331/notes/FirstFollow.pdf">Follow Set</a>. Si un non-terminal est utilisé dans des contextes très différents, son ensemble peut être spécialisé et réduit
pour chaque règle où il est utilisé.</p>
<p>Voici pour notre grammaire le résultat du calcul des ensembles First et Follow :</p>
<h3 id="first-set"><a class="header" href="#first-set">First Set</a></h3>
<pre><code>First(KaleFile) = { IDENT }
First(Assignment) = { IDENT }
First(Value) = { INTEGER, IDENT, STRING }
First(MulDivValue) = { INTEGER, IDENT, STRING }
First(AtomValue) = { INTEGER, IDENT, STRING }
</code></pre>
<h3 id="follow-set"><a class="header" href="#follow-set">Follow Set</a></h3>
<pre><code>Follow(Assignment) = { IDENT, EOF }
Follow(Value) = { IDENT, EOF }
Follow(MulDivValue) = { ADD, SUBSTRACT, IDENT, EOF }
Follow(AtomValue) = { ADD, SUBSTRACT, MULTIPLY, DIVIDE, IDENT, EOF }
</code></pre>
<h2 id="résultat-3"><a class="header" href="#résultat-3">Résultat</a></h2>
<p>Le parser ne s'arrête plus à la première erreur et rapporte précisément l'erreur. Par exemple sur le programme suivant :</p>
<pre><code>my_var := 10 / + 30
my_other_var + 20
</code></pre>
<p>L'interpréteur affiche maintenant le diagnostic d'erreur suivant :</p>
<pre><code>my_var := 10 / + 30
               ^
[0] Expecting STRING, got ADD

my_other_var + 20
             ^
[1] Expecting ASSIGN, got ADD
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sémantique-du-langage-kale"><a class="header" href="#sémantique-du-langage-kale">Sémantique du langage Kale</a></h1>
<p><code>step-2.5</code></p>
<p>Comme vu lors des observations, il est possible d'écrire des programmes faux sans que l'interpréteur nous indique la présence d'erreurs
(ie. opérations inconsistantes, variable non définie, etc.). Ce type de comportement non autorisé est généralement donné
par la <a href="https://en.wikipedia.org/wiki/Denotational_semantics">sémantique dénotationnelle</a>. Pour (beaucoup) simplifier,
contrairement à la sémantique opérationnelle qui définit l'évaluation du programme, la sémantique dénotationnelle permet de
transformer le programme sous la forme d'une fonction mathématique (généralement à base de lambda-calcul). Cette transformation
s'apparente plus à la compilation et est souvent utilisée comme spécification d'un compilateur.</p>
<p>En particulier, une des tâches de la sémantique est de typer précisément les différentes constructions du langage et
d'identifier les incohérences de typage. Ceci se fait par un mécanisme d'inférence de types : le typage des variables se construit
automatiquement à partir du typage de leur valeur.</p>
<p>Chaque construction équivalente au non-terminal <code>Value</code> de la grammaire ainsi que la définition des variables se voit affecter une valeur du type :</p>
<pre><code class="language-typescript">enum Type {
  INTEGER,
  STRING,
  UNKNOWN
}
</code></pre>
<p>selon les règles suivantes :</p>
<ul>
<li>INTEGER pour les valeurs simples de type entier ou le résultat de toutes les opérations exécutées sur des opérandes de type ENTIER</li>
<li>STRING  pour les valeurs simples de type chaîne ou le résultat de l'opération <code>+</code> ayant au moins un opérande de type STRING</li>
<li>UNKNOWN pour tous les autres cas, c.-à-d. :
<ul>
<li>mauvais typage d'opération ;</li>
<li>variable non définie ;</li>
<li>construction du langage incomplète due à une erreur d'analyse grammaticale.</li>
</ul>
</li>
</ul>
<p>Grâce au typage, l'analyse sémantique peut rapporter les utilisations interdites des opérations <code>-</code>, <code>*</code> et <code>/</code>.</p>
<h1 id="résultat-4"><a class="header" href="#résultat-4">Résultat</a></h1>
<p>Les programmes invalides ne sont plus exécutés et, par exemple, sur le programme suivant :</p>
<pre><code>my_var := 10 / value
message := 20 * "30"
</code></pre>
<p>L'interpréteur affiche maintenant le diagnostic d'erreur suivant :</p>
<pre><code>my_var := 10 / value
               ^^^^^
[0] Unknown variable 'value'

message := 20 * "30"
           ^^^^^^^^^
[1] Cannot use '*' on strings
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="découverte-des-extensions-vscode"><a class="header" href="#découverte-des-extensions-vscode">Découverte des extensions VSCode</a></h1>
<p>Nous disposons maintenant de tous les composants spécifiques à notre langage pour tenter
de créer un support de langage intégré à VSCode.</p>
<h2 id="serveur-de-langage-et-protocole-lsp"><a class="header" href="#serveur-de-langage-et-protocole-lsp">Serveur de langage et protocole LSP</a></h2>
<p>VSCode est à l'origine d'une architecture originale en ce qui concerne l'organisation du code
d'une IDE, les aspects graphique et langage sont complètement séparés :</p>
<ul>
<li>un client graphique incluant des éditeurs, navigateurs, menus, etc. gère l'ensemble de l'interaction avec l'utilisateur ;</li>
<li>des serveurs gèrent les analyses et traitements spécifiques à chaque langage ;</li>
<li>le client et les serveurs communiquent par un protocole bien défini et ouvert : le
<a href="https://microsoft.github.io/language-server-protocol/"><strong>Language Server Protocol</strong></a>.</li>
</ul>
<p>Le protocole étant ouvert, il peut être implémenté par plusieurs éditeurs et permet ainsi à
un serveur de langage d'être disponible pour l'ensemble de ces éditeurs. À l'inverse tout éditeur
implémentant le protocole bénéficie immédiatement de tous les serveurs de langages existants.
Le protocole est un protocole bidirectionnel basé sur <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON RPC</a> et
dans sa version la plus simple, le serveur communique avec le client par ses entrée/sortie standards
(les versions plus élaborée acceptent d'autres canaux de communication comme les sockets TCP).</p>
<h2 id="découverte-du-protocole"><a class="header" href="#découverte-du-protocole">Découverte du protocole</a></h2>
<p>Dans un premier terminal, lancez la commande suivante:</p>
<pre><code class="language-bash">nc -Cl 5050
</code></pre>
<p>Elle permet d'ouvrir un socket TCP en écoute sur le port 5050 (<code>-C</code> permet de convertir les retours chariot en CRLF).
Dans un second terminal, dans un répertoire temporaire installez et lancez le serveur de langage Docker
(c'est un exemple, d'autres serveurs de langage peuvent être utilisés) :</p>
<pre><code class="language-bash">npm install dockerfile-language-server-nodejs
./node_modules/.bin/docker-langserver --socket=5050
</code></pre>
<p>au lancement du serveur rien ne se passe : c'est au client d'envoyer le premier message. Copier dans le premier terminal
(celui qui exécute actuellement la commande <code>nc</code>) le message suivant au caractère prêt (depuis <code>Content-Length</code> jusqu'à la dernière <code>}</code>) :</p>
<pre><code class="language-json">Content-Length: 101

{"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": { "capabilities": {"workspace": {}}}}
</code></pre>
<p>Le premier échange est une négociation de capacités, le client et le serveur échangent leurs fonctionnalités respectives.
On peut ensuite simuler l'ouverture d'un fichier depuis le client :</p>
<pre><code class="language-json">Content-Length: 175

{"jsonrpc": "2.0", "method": "textDocument/didOpen", "params": { "textDocument": {"uri":"file:///tmp/Dockerfile","languageId":"dockerfile","version":1,"text":"HELLO tutu"}}}
</code></pre>
<p>Vous remarquerez que le message n'a pas d'identifiant : c'est une notification, aucune réponse n'est attendue. En réaction,
le serveur notifie le client qu'il a analysé le document et que ce dernier contient des erreurs : l'instruction <code>HELLO</code> est inconnue
et le document doit contenir une référence à une image avec l'instruction <code>FROM</code>. Le serveur est informé des modifications du document
en temps réel :</p>
<pre><code class="language-json">Content-Length: 247

{"jsonrpc": "2.0", "method": "textDocument/didChange", "params": { "textDocument": {"uri":"file:///tmp/Dockerfile","version":2}, "contentChanges": [{"range": {"start":{"line":0,"character":0},"end":{"line":0,"character":10}}, "text": "FROM "}]}}
</code></pre>
<p>C'est mieux : le document ne contient plus qu'une erreur. Il est possible de lui demander des propositions de complétion après le mot clé <code>FROM</code> :</p>
<pre><code class="language-json">Content-Length: 167

{"jsonrpc": "2.0", "id": 2, "method": "textDocument/completion", "params": { "textDocument": {"uri":"file:///tmp/Dockerfile"}, "position": {"line":0,"character":5}}}
</code></pre>
<p>Le document peut de nouveau être modifié :</p>
<pre><code class="language-json">Content-Length: 254

{"jsonrpc": "2.0", "method": "textDocument/didChange", "params": { "textDocument": {"uri":"file:///tmp/Dockerfile","version":2}, "contentChanges": [{"range": {"start":{"line":0,"character":0},"end":{"line":0,"character":10}}, "text": "FROM hello\n"}]}}
</code></pre>
<p>Il ne contient plus d'erreurs, on peut maintenant tenter une demande de complétion dans un autre contexte :</p>
<pre><code class="language-json">Content-Length: 167

{"jsonrpc": "2.0", "id": 2, "method": "textDocument/completion", "params": { "textDocument": {"uri":"file:///tmp/Dockerfile"}, "position": {"line":1,"character":0}}}
</code></pre>
<p>Le serveur nous propose maintenant l'ensemble des mots clés pouvant être utilisé à cet endroit du document.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Cette session montre qu'il est facile de communiquer avec un serveur de language, mais n'est pas des plus pratiques.
Des bibliothèques implémentant le protocole existent dans à peu prêt tous les langages de programmation et vous permettent
de ne plus manipuler le Json et les messages à la main.</p>
<p>Dans la partie suivante l'infrastructure minimale va être mise en place afin de réaliser un serveur de langage spécifique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serveur-de-langage-kale"><a class="header" href="#serveur-de-langage-kale">Serveur de langage Kale</a></h1>
<p><code>step 3.1</code></p>
<p>Le serveur de langage repose sur la bibliothèque <code>vscode-languageserver</code>. Afin de disposer de ces nouvelles dépendances, lancez la commande :</p>
<pre><code>npm install
</code></pre>
<p>L'objet principal qui centralise toute l'infrastructure du serveur est l'objet obtenu avec la fonction <code>createConnection</code> :</p>
<pre><code class="language-typescript">import { createConnection, ProposedFeatures } from "vscode-languageserver/node";

const connection = createConnection(ProposedFeatures.all);

/*
 * ... more initialisations
 */

connection.listen();
</code></pre>
<p>Pour chaque requête ou notification à traiter l'objet <code>connection</code> propose un <em>hook</em> pour intercepter le message et dans le cas
d'une requête pouvoir envoyer la réponse. Par exemple :</p>
<pre><code class="language-typescript">import { InitializeParams, InitializeResult, TextDocumentSyncKind } from "vscode-languageserver";

connection.onInitialize((params: InitializeParams): InitializeResult =&gt; {
	return {
		capabilities: {
			textDocumentSync: TextDocumentSyncKind.Incremental,
		} as any
	}
});
</code></pre>
<p>Le serveur doit garder une version des documents ouverts afin de suivre leur modifications. La bibliothèque <code>vscode-languageserver</code>
met à disposition la fonction <code>TextDocument.create()</code> pour créer des documents sur lesquels la fonction <code>TextDocument.applyEdits()</code>
permet d'appliquer les modifications. A chaque action sur un document (ouverture, changement et fermeture) le document doit être
validé avec notre lexer/parser/checker maison et les erreurs publiées sous forme de diagnostiques avec la méthode <code>connection.sendDiagnostics()</code>.</p>
<h1 id="résultat-5"><a class="header" href="#résultat-5">Résultat</a></h1>
<p>Ça y est votre serveur de langage est prêt ! Mais sans un vrai client graphique l'expérience est plutôt limitée.
Dans le chapitre suivant une extension VSCode va être développée pour communiquer avec notre serveur.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialisation-du-projet-dextension-vscode"><a class="header" href="#initialisation-du-projet-dextension-vscode">Initialisation du projet d'extension VSCode</a></h1>
<p>La première étape consiste à créer le projet correspondant à l'extension VSCode.
La procédure est tirée de <a href="https://code.visualstudio.com/docs/extensions/example-hello-world">la documentation officielle</a>
de VSCode et utilise le générateur de code <a href="http://yeoman.io/">Yeoman</a>.</p>
<pre><code>npm install -g yo generator-code
yo code
</code></pre>
<p>Répondez aux questions dans l'ordre :</p>
<ul>
<li><code>New Extension (Typescript)</code> pour le type d'extension</li>
<li><code>Kale Extension</code> comme nom d'extension</li>
<li><code>kale-extension</code> comme identifiant de l'extension</li>
<li>entrez une description</li>
<li>et choisissez ou pas d'initialiser un dépôt Git</li>
<li>enfin choisissez le gestionnaire de package npm</li>
</ul>
<p>Le projet généré est un projet VSCode, ouvrez l'IDE avec la commande :</p>
<pre><code>code kale-extension
</code></pre>
<p>Le fichier <code>package.json</code> est le point d'entrée de l'extension (l'extension elle même est un package Node).
Il déclare une nouvelle commande <code>extension.sayHello</code> et indique que l'extension est activée lorsque cette
commande est invoquée.</p>
<p>Tout le code de l'extension est dans le fichier <code>src/extension.ts</code>.
Il comporte deux fonctions obligatoires <code>activate</code> et <code>deactivate</code>.
La première, appelée au démarrage de l'extension, donne la définition de la commande qui permet d'afficher
le fameux message d'information <code>Hello world!</code>.</p>
<p>Démarrez l'extension comme indiqué dans la documentation en appuyant sur la touche <code>F5</code>.
Une nouvelle instance de l'IDE démarre avec la nouvelle extension disponible.
Lancer la commande Hello en appuyant sur <code>F1</code> et en sélectionnant la commande : le message s'affiche dans un toaster.</p>
<p>Remarquer également l'affichage du log dans la console lors de l'activation de l'extension.</p>
<h1 id="définition-des-contributions-de-lextension"><a class="header" href="#définition-des-contributions-de-lextension">Définition des contributions de l'extension</a></h1>
<p>Notre extension va permettre de gérer un nouveau type de fichier, il faut pour
cela remplacer la section <code>contributes</code> dans le fichier <code>package.json</code> par :</p>
<pre><code class="language-json">"contributes": {
  "languages": [{
    "id": "kale",
    "extensions": [ ".kl" ],
    "aliases": [ "Kale" ]
  }]
}
</code></pre>
<p>Démarrez de nouveau l'instance de test de l'IDE (<code>F5</code>) et ouvrez le fichier <code>examples/simple_example.kl</code> (<code>CTRL+O</code>),
vous pouvez constater que le type de fichier est bien reconnu avec l'apparition du type de fichier <code>Kale</code> (au lieu de <code>Plain Text</code>)
dans la barre de statut en bas à droite.</p>
<p>A part reconnaître un type de fichier, l'extension ne fait, pour l'instant, pas grand chose.
Pour aller un peu plus loin il est possible de définir une autre contribution :</p>
<pre><code class="language-json">"grammars": [{
  "language": "kale",
  "scopeName": "source.kale",
  "path": "syntax-kale.json"
}]
</code></pre>
<p>Cette contribution permet de définir la coloration syntaxique pour le langage <code>kale</code>.
La définition du langage utilise le formalisme de l'éditeur de texte <a href="https://manual.macromates.com/en/language_grammars">TextMate</a>.
Créer le fichier <code>syntax-kale.json</code> à la racine de l'extension avec le contenu suivant :</p>
<pre><code class="language-json">{
  "scopeName": "source.kale",
  "patterns": [
    {
      "name": "comment.double-slash.kale",
      "match": "//.*\\n"
    },
    {
      "match": "\\b(\\w+)\\s*(:=)",
      "captures": {
        "1": {
          "name": "entity.name.other.kale"
        },
        "2": {
          "name": "punctuation.definition.entity.kale"
        }
      }
    },
    {
      "match": "\\d+",
      "name": "constant.numeric.integer.kale"
    },
    {
      "name": "string.quoted.double.kale",
      "begin": "\"",
      "end": "\""
    }
  ]
}
</code></pre>
<p>L'éditeur dispose maintenant de la coloration syntaxique (ou plutôt lexicale pour être exact),
cette coloration dépend des catégories prédéfinies préfixées par <code>comment</code>, <code>keyword</code>, etc. et s'adapte
donc automatiquement au thème de couleurs actif.</p>
<p>Il est donc relativement facile de personnaliser l'IDE pour un nouveau langage sans écrire de code.
Ces personnalisations restent cependant très superficielles et les fonctionnalités telles que l'affichage
d'erreurs en ligne ou la complétion de code ne sont, quant-à-elles, possibles que par l'ajout de code.</p>
<p>L'activation de l'extension ne peut plus se faire sur la commande <code>sayHello</code> que nous
avons supprimée, mais sur l'ouverture d'un fichier de type Kale. Modifier le fichier <code>package.json</code>
pour inclure le code suivant :</p>
<pre><code class="language-json">"activationEvents": [
  "onLanguage:kale"
]
</code></pre>
<p>Le message dans la console de débuggage doit de nouveau apparaître à l'ouverture d'un fichier Kale.</p>
<h1 id="communication-avec-le-serveur-de-langage"><a class="header" href="#communication-avec-le-serveur-de-langage">Communication avec le serveur de langage</a></h1>
<p>Pour communiquer avec le serveur de langage et profiter de ses fonctionnalités, il est nécessaire d'ajouter une librairie cliente<sup class="footnote-reference"><a href="#1">1</a></sup> :</p>
<pre><code>npm install vscode-languageclient@9.0.1
</code></pre>
<p>Et vu que notre serveur de langage est également un package Node, pour simplifier la distribution,
on l'installe également comme une dépendance, locale cette fois pour simplifier le développement
(cela va nous permettre de modifier le serveur sans avoir à réinstaller la dépendance) :</p>
<pre><code>npm install ${CHEMIN_VERS}/kale-language-server
</code></pre>
<p>Remplacer le fichier <code>src/extension.ts</code> par le code TypeScript suivant qui se limite simplement à démarrer le serveur
en indiquant le chemin vers son point d'entrée et quel type de documents il gère :</p>
<pre><code class="language-typescript">import * as path from 'path';
import * as vscode from 'vscode';
import { LanguageClient, ServerOptions, LanguageClientOptions, TransportKind } from 'vscode-languageclient';

export function activate(context: vscode.ExtensionContext) {

    const serverModule = context.asAbsolutePath(
        path.join(
            "node_modules",
            "kale-language-server",
            "lib",
            "server.js"
        )
    );

    const serverOptions: ServerOptions = {
        module: serverModule,
        transport: TransportKind.ipc
    };

    const clientOptions: LanguageClientOptions = {
        documentSelector: [ "kale" ],
    };

    const client = new LanguageClient(
        "kale-langserver",
        "Kale Language Server",
        serverOptions,
        clientOptions
    );
       
    client.start();
}

export function deactivate() {
}
</code></pre>
<p>Ici nous profitons de facilités offertes par le fait que notre serveur s'exécute avec NodeJS, mais il est également possible
de lancer n'importe quel exécutable de son choix et de choisir le mode de communication avec le client (stdio, socket, etc.).</p>
<p>L'édition d'un fichier Kale dans l'éditeur de test permet maintenant de constater que les erreurs s'affichent automatiquement
à la frappe au clavier.</p>
<h1 id="packaging-de-lextension"><a class="header" href="#packaging-de-lextension">Packaging de l'extension</a></h1>
<p>Une fois satisfait des fonctionnalités de votre extension, il est temps de la packager pour pouvoir la distribuer à vos collègues,
pour cela installez l'outil <code>vsce</code> :</p>
<pre><code>npm install -g vsce
</code></pre>
<p>Malheureusement un <a href="https://github.com/microsoft/vscode-vsce/issues/203">bug</a> de l'outil nous force
à d'abord packager localement <code>kale-language-server</code>, pour cela créer dans le projet le fichier <code>.npmignore</code>
contenant :</p>
<pre><code>.vscode/
src/
examples/
tsconfig.json
.mocharc.json
.gitignore
</code></pre>
<p>afin d'exclure les fichiers servant uniquement au développement. Puis lancez la commande :</p>
<pre><code>npm pack
</code></pre>
<p>afin de packager le projet et d'obtenir le <code>.tar.gz</code> correspondant.</p>
<p>Enfin dans le projet d'extension, ajouter dans le fichier <code>package.json</code> le champ <code>publisher</code> avec par exemple votre nom.
Si vous voulez publier l'extension sur le MarketPlace VSCode, ce nom devra d'abord avoir été déclaré en vous enregistrant.</p>
<p>Ensuite il faut remplacer la dépendance directe sur le répertoire du projet du serveur de langage par une référence sur le
<code>.tar.gz</code> et utiliser <code>vsce</code> afin de packager l'extension :</p>
<pre><code class="language-bash">npm install ${CHEMIN_VERS}/kale-language-server/kale-language-server-1.0.0.tgz
vsce package
</code></pre>
<p>ce qui permet enfin d'obtenir le package d'extension <code>.vsix</code>. Depuis VSCode, cette extension peut être installée avec
la commande <code>Extensions: install from VSIX...</code> (<code>CTRL-SHIFT-P</code> pour ouvrir la palette).</p>
<p>Il est à noter que dans le cas d'une extension embarquant la partie cliente et serveur, le projet devrait adopter l'organisation de
fichiers de l'exemple <a href="https://github.com/microsoft/vscode-extension-samples/tree/master/lsp-sample">officiel</a> afin de simplifier la gestion
des dépendances et du packaging.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>La version majeure 7.x de <code>vscode-languageclient</code> a malheureusement une API incompatible. il y a encore du pain sur la planche...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extension-vim"><a class="header" href="#extension-vim">Extension Vim</a></h1>
<p>VSCode est à l'origine du protocole LSP, mais aujourd'hui un nombre croissant d'autres
<a href="https://microsoft.github.io/language-server-protocol/implementors/tools/">éditeurs</a> permet
de se connecter à un serveur de langage, c'est le cas du célèbre éditeur <strong>Vim</strong>. Cette fonctionnalité n'est pas native,
mais l'adjonction de plugins et un peu de configuration lui permet de délivrer les
mêmes sensations que votre IDE préférée !</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Il faut tout d'abord installer le gestionnaire de plugin <a href="https://github.com/junegunn/vim-plug">vim-plug</a>.</p>
<p>Ensuite éditez votre fichier de configuration <code>~/.vimrc</code> en y ajoutant :</p>
<pre><code class="language-bash">call plug#begin('~/.vim/plugged')

Plug 'natebosch/vim-lsc'

call plug#end()
</code></pre>
<p>Cette configuration va permettre d'installer <a href="https://github.com/natebosch/vim-lsc">vim-lsc</a>, qui va faire
le pont entre Vim et les serveurs de langages. Pour finaliser l'installation, lancez Vim et taper la commande :</p>
<pre><code>:PlugInstall
</code></pre>
<p>Après téléchargement, il ne reste plus qu'à déclarer le lien entre type de fichier et serveur de langage,
dans votre fichier <code>~/.vimrc</code>, ajoutez :</p>
<pre><code class="language-bash">au BufRead,BufNewFile *.kl set filetype=kale
</code></pre>
<p>Cette configuration (native de Vim) permet d'affecter le type <code>kale</code> aux fichiers d'extension <code>.kl</code>.
À partir de là, il serait également possible d'écrire un fichier définissant la coloration syntaxique,
libre à vous d'en écrire un à l'aide de ce <a href="https://vim.fandom.com/wiki/Creating_your_own_syntax_files">tutoriel</a>.</p>
<p>Finalement pour ajouter le lien entre le type de fichier <code>kale</code> et notre serveur de langage, ajoutez au fichier <code>~/.vimrc</code> :</p>
<pre><code class="language-bash">let g:lsc_server_commands = {
  \ 'kale': '${KALE_LANGUAGE_SERVER}/bin/kale-langserver --stdio'
  \ }
</code></pre>
<p>en remplaçant <code>${KALE_LANGUAGE_SERVER}</code> par le chemin complet vers le script de lancement du serveur (vous pouvez également
mettre le répertoire <code>bin</code> dans votre <code>PATH</code>).</p>
<h2 id="résultat-6"><a class="header" href="#résultat-6">Résultat</a></h2>
<p>Vous pouvez éditer vos fichiers Kale avec Vim comme d'habitude mais avec maintenant l'affichage des erreurs à la frappe !
En fonction des capacité du serveur de langage utilisé, il est également possible d'utiliser la complétion, réfactoring, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="langage-amélioré"><a class="header" href="#langage-amélioré">Langage amélioré</a></h1>
<p>Maintenant que vous disposer d'un éditeur confortable, vous avez pu tester l'édition de fichier Kale
plus intensément et vous avez pu remarquer que dans certaines situations il rapporte bien plus d'erreur
que ce qu'on l'on pourrait imager. Dans l'exemple suivant :</p>
<pre><code class="language-bash">my_var := 10 +
other_var := 100 * my_var
message := "result " + other_var
</code></pre>
<p>en l'absence de délimiteur de fin d'affectation tel que <code>;</code> typique des langages inspirés du C,
l'analyseur n'a aucun moyen de savoir qu'un identifiant démarre ou pas une affectation et, au lieu de déclarer
une expression invalide, l'erreur déborde sur l'affectation suivante qui se retrouve à son tour en erreur et ainsi de proche en proche.</p>
<p>Inconsciemment en tant que développeur, nous organisons notre code afin de le rendre plus lisible et
nous voyons rapidement que seule la première affectation est invalide, les deux autres prises indépendamment sont parfaitement valides.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>step-4.1</code></p>
<p>Le langage peut être amélioré en utilisant les informations de layout et distinguer les identifiants qui démarrent une nouvelle ligne des autres.</p>
<h2 id="résultat-7"><a class="header" href="#résultat-7">Résultat</a></h2>
<p>L'exemple précédent ne doit maintenant comporter qu'une seule erreur. Cet exemple montre que, bien que les deux versions du langage
permettent d'exprimer la même chose, la nouvelle version est beaucoup plus robuste à l'édition et augmente drastiquement
la productivité de ses utilisateurs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonctionnalités-avancées"><a class="header" href="#fonctionnalités-avancées">Fonctionnalités avancées</a></h1>
<p>L'affichage automatique des erreurs en temps réel c'est bien, mais on peut faire mieux !
L'outillage idéal doit également être capable de faire des propositions pour aider l'utilisateur
à améliorer son code. Nous allons implémenter deux types d'aides :</p>
<ul>
<li>la complétion des noms de de variables ;</li>
<li>proposer et appliquer un refactoring de code.</li>
</ul>
<h2 id="complétion-des-variables"><a class="header" href="#complétion-des-variables">Complétion des variables</a></h2>
<p><code>step-5.1</code></p>
<p>À cette étape le nouveau module <code>complete.ts</code> permet de définir le code calculant les complétions possibles à une position donnée :</p>
<pre><code class="language-typescript">export interface Completion {
    value: string;
}

export function complete(content: string, position: Position): Completion[] {
    throw new Error("TODO");
}
</code></pre>
<p>Le contenu d'une complétion est simplement une chaîne de caractères représentant le nom d'une variable.
Lors de la phase sémantique on est capable d'accumuler l'état des variables connues (et leur type) à un point donnée du programme.
Cet état peut être utilisé pour proposer des complétions du nom d'une variable, la variable proposée doit être valide à cet endroit
et le type de l'expression courante doit être utilisé.</p>
<p>Le module <code>positions.ts</code> offre une nouvelle fonction <code>isIn()</code> qui permet de tester qu'une position et contenue dans l'intervalle d'une construction
du langage, en particulier une référence à une variable.</p>
<p><code>step-5.2</code></p>
<p>Cette étape consiste simplement à utiliser la nouvelle fonction <code>complete</code> dans le serveur de langage afin
d'implémenter la réponse à la requête <code>textDocument/completion</code>.</p>
<p>Une fois l'ensemble des tests passant, vous pouvez maintenant tester la complétion des noms de variables en relançant l'extension VSCode
et éditer l'exemple suivant :</p>
<pre><code class="language-c">// Calcul du prix total
prix_unitaire := 10
forfait := 100
fixe := 10
total := f * prix_unitaire
</code></pre>
<p>En activant la complétion (<code>CTRL-espace</code>) juste derrière le <code>f</code> de la dernière ligne, vous devez obtenir le résultat de l'image suivante :</p>
<p><img src="05_AdvanceFeatures/completions.png" alt="Résultat de la complétion" /></p>
<h2 id="réfactoring"><a class="header" href="#réfactoring">Réfactoring</a></h2>
<p><code>step-5.3</code></p>
<p>en plus de la détection des erreurs, nous allons ajouter à la phase de vérification sémantique
la détection des variables inutilisées. Ce diagnostique de type <em>hint</em> sera rapporté avec une nouvelle fonction :</p>
<pre><code class="language-typescript">export interface ErrorReporter {
    reportHint(span: Span, message: string, code: string): void;
}
</code></pre>
<p>par rapport à la fonction <code>reportError</code> en plus du message, un code indique le type de l'amélioration détecté. Ce code est défini
par le type suivant :</p>
<pre><code class="language-typescript">export enum RefactoringAction {
    UNUSED_DEFINITION = "0001"
}
</code></pre>
<p>Une fois les tests passant, vous pouvez vérifier que sur l'exemple suivant :</p>
<pre><code class="language-c">my_var := 10
message := "10"
</code></pre>
<p>la première ligne apparaît comme commentée (grâce à la propriété <code>DiagnosticTag.Unnecessary</code>) et le diagnostique associé
indique que la définition n'est pas utilisée :</p>
<p><img src="05_AdvanceFeatures/unused_definition.png" alt="Définition non utilisée" /></p>
<p><code>step-5.4</code></p>
<p>Dans l'image précédente vous pouvez remarquer que la tooltip indique qu'il n'y a pas de <em>quick fixes</em> disponibles,
nous allons maintenant ajouter le refactoring associé à une définition non utilisée.</p>
<p>Pour cela le nouveau module <code>codeaction.ts</code> a été ajouté et comporte la fonction principale <code>findCodeActions</code> :</p>
<pre><code class="language-typescript">export interface Action {
    title: string;
    span: Span;
    newText: string;
}

export function findCodeActions(content: string, span: Span): Action[] {
    throw new Error("TODO");
}
</code></pre>
<p>Cette fonction renvoie l'ensemble des actions exécutables dans l'intervalle de la sélection passée en paramètre.
Un action a un nom et permet définit l'édition de texte associé : l'intervalle <code>span</code> est remplacé par le texte <code>newText</code>.
Les actions possibles sont trouvées en collectant l'ensemble des <em>hints</em> de type «définition inutilisée» qui se recouvre
l'intervalle sélectionné (grace à la fonction <code>overlap</code> du module <code>positions.ts</code>).</p>
<p>Enfin la fonction <code>findCodeActions</code> est utilisée dans le serveur afin de répondre aux requêtes <code>textDocument/codeAction</code>.</p>
<p>Une fois les tests passant, vous pouvez vérifier que sur le même exemple que précédemment :</p>
<pre><code class="language-c">my_var := 10
message := "10"
</code></pre>
<p>si le curseur est placé sur la première ligne, une ampoule apparaît indiquant que des actions sont possibles
à cet endroit. Le raccourci clavier <code>CTRL-SHIFT-;</code> permet d'ouvrir le menu de sélection des actions comme
visible sur l'image suivante :</p>
<p><img src="05_AdvanceFeatures/code_actions.png" alt="Réfactoring proposé" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h1>
<p>Voilà ! c'est la fin de ce tutoriel, mais c'est seulement le début de vos explorations dans le monde
des serveurs de langage, rien que sur notre exemple de langage, des dizaines de fonctionnalités peuvent être ajoutées :</p>
<ul>
<li>ajouter une action de réfactoring sur les variables indéfinies pour leur ajouter une définition</li>
<li>afficher les définitions et références correspondant à une variable en répondant à la requête <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_documentHighlight"><code>textDocument/documentHighlight</code></a></li>
<li>ajouter le réfactoring de renommage en répondant à la requête <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_rename"><code>textDocument/rename</code></a></li>
<li>formater le code en répondant à la requête <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting"><code>textDocument/formatting</code></a></li>
<li>etc.</li>
</ul>
<p>Vous pouvez également tester des évolutions du langage lui même en ajoutant :</p>
<ul>
<li>l'ajout de conditions sur les affectations ;</li>
<li>l'interpolation de variables dans les chaînes de caractères ;</li>
<li>l'appel de fonctions ;</li>
<li>etc.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
